<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Stay Hungry. Stay Foolish.">
<meta property="og:type" content="website">
<meta property="og:title" content="不要急，不要怕">
<meta property="og:url" content="http://yoursite.com/child/page/2/index.html">
<meta property="og:site_name" content="不要急，不要怕">
<meta property="og:description" content="Stay Hungry. Stay Foolish.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="不要急，不要怕">
<meta name="twitter:description" content="Stay Hungry. Stay Foolish.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/child/page/2/"/>





  <title> 不要急，不要怕 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">不要急，不要怕</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Life needs curiosity and passion.</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/child/2016/12/21/基于socket的“抽奖”/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="hapii">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://tva1.sinaimg.cn/crop.0.14.750.750.180/005PluWajw8fahgdnankoj30ku0lnjsd.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="不要急，不要怕">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="不要急，不要怕" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/21/基于socket的“抽奖”/" itemprop="url">
                  基于socket的“抽奖”
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-21T10:22:01+08:00">
                2016-12-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/12/21/基于socket的“抽奖”/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/21/基于socket的“抽奖”/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/12/21/基于socket的“抽奖”/" class="leancloud_visitors" data-flag-title="基于socket的“抽奖”">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>socket（套接字）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。</p>
<p>多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。为了区别不同的应用程序进程和连接，计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p>
<p>建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket。套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。</p>
<p>Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接,UDP连接同理。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-6b9392fad31b711d.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt="原理图"></p>
<h2 id="AsyncUdpSocket"><a href="#AsyncUdpSocket" class="headerlink" title="AsyncUdpSocket:"></a>AsyncUdpSocket:</h2><p>这里用到了一个三方AsyncUdpSocket,<a href="http://code.google.com/p/cocoaasyncsocket/" target="_blank" rel="external">原来的下载地址</a>不过现在不能用了,github有类似的，应该也可以直接用。这套抽奖是socket的及其简单的应用，写两套代码分别给操作端和现实端。</p>
<p><img src="http://i1.piimg.com/567571/687e886eb093e4d7.gif" alt="先来张图"><br>抽奖时用的是随机数对20取余，而最后的“现在”就是通过socket发送到现实端的。</p>
<h2 id="显示端"><a href="#显示端" class="headerlink" title="显示端:"></a>显示端:</h2><p>代码很简单，这里我就直接粘了:</p>
<pre><code>#import &quot;ViewController.h&quot;
#import &quot;AsyncUdpSocket.h&quot;
#import &lt;AVFoundation/AVFoundation.h&gt;

#define RandomColor [UIColor colorWithRed:arc4random_uniform(256)/255.0 green:arc4random_uniform(256)/255.0 blue:arc4random_uniform(256)/255.0 alpha:1.0]//随机色

#define screenWidth [UIScreen mainScreen].bounds.size.width
#define screenHeight [UIScreen mainScreen].bounds.size.height


@interface ViewController ()&lt;AsyncUdpSocketDelegate&gt;{
AsyncUdpSocket *_socket;
NSTimer *_timer;
NSString *_lastStr;
UIButton *startBut;


}

@property (nonatomic,strong)AVPlayer *player;
@property (nonatomic,strong)UILabel *label;

@end

@implementation ViewController

//懒加载播放器
- (AVPlayer *)player{
if (_player == nil) {
    // 1.获取URL(远程/本地)
     NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;M11-01-05-57.mp3&quot; withExtension:nil];
    //NSURL *url = [NSURL URLWithString:@&quot;http://v1.mukewang.com/a45016f4-08d6-4277-abe6-bcfd5244c201/L.mp4&quot;];

    // 2.创建AVPlayerItem
    AVPlayerItem *item = [AVPlayerItem playerItemWithURL:url];

    // 3.创建AVPlayer
    _player = [AVPlayer playerWithPlayerItem:item];

    // 4.添加AVPlayerLayer
    AVPlayerLayer *layer = [AVPlayerLayer playerLayerWithPlayer:self.player];
    layer.frame = CGRectMake(0, 0, self.view.bounds.size.width, self.view.bounds.size.width * 9 / 16);
    [self.view.layer addSublayer:layer];
}
return _player;}

//搭建页面    
- (void)viewDidLoad {
[super viewDidLoad];

_label = [[UILabel alloc] initWithFrame:CGRectMake(screenWidth/2-150, 100, 300, 300)];
_label.backgroundColor = [UIColor orangeColor];
_label.font = [UIFont systemFontOfSize:33.0f weight:21];
_label.textAlignment = NSTextAlignmentCenter;
[self.view addSubview:self.label];

startBut = [[UIButton alloc] initWithFrame:CGRectMake(screenWidth/2-50, screenHeight-200, 100, 50)];
[startBut setBackgroundColor:[UIColor redColor]];
[startBut setTitle:@&quot;开始抽奖&quot; forState:UIControlStateNormal];
[startBut addTarget:self action:@selector(LetUsBegin) forControlEvents:UIControlEventTouchUpInside];
[self.view addSubview:startBut];



_socket = [[AsyncUdpSocket alloc]initIPv4];
_socket.delegate = self;
//ip 和 端口号//这个重电脑的网络看，必需要一致
[_socket bindToAddress:@&quot;10.10.5.32&quot; port:9444 error:nil];

//保持连接
[_socket receiveWithTimeout:-1 tag:0];
</code></pre><p>}</p>
<p>//点击了开始抽奖按钮</p>
<pre><code>- (void)LetUsBegin{
 startBut.hidden = YES;
[self.player play];
_timer = [NSTimer scheduledTimerWithTimeInterval:0.4 target:self selector:@selector(ChangeLabelText) userInfo:nil repeats:YES];

[[NSRunLoop currentRunLoop] addTimer:_timer forMode:NSDefaultRunLoopMode];

dispatch_after(dispatch_time(DISPATCH_TIME_NOW,(int64_t)(9* NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
    [self stopTimer];
});
</code></pre><p>}</p>
<p>10秒过后停止</p>
<pre><code>- (void)stopTimer{
[_timer invalidate];
_timer = nil;
if (_lastStr) {
     _label.text  = _lastStr;
}else{
    _label.text = [NSString stringWithFormat:@&quot;%i&quot;,arc4random()%30];
}
   startBut.hidden = NO;
_label.backgroundColor = RandomColor;
_lastStr = nil;
self.player = nil;
}
</code></pre><p>定时器方法,</p>
<pre><code>- (void)ChangeLabelText{
_label.text = [NSString stringWithFormat:@&quot;%i&quot;,arc4random()%20];
_label.backgroundColor = RandomColor;
</code></pre><p>}</p>
<p>socket代理方法</p>
<pre><code>-(BOOL)onUdpSocket:(AsyncUdpSocket *)sock didReceiveData:(NSData *)data withTag:(long)tag fromHost:(NSString *)host port:(UInt16)port{

_lastStr =  [[NSString alloc] initWithData:data  encoding:NSUTF8StringEncoding];
  //保持连接
    [_socket receiveWithTimeout:-1 tag:0];
 return YES;
</code></pre><p>}</p>
<h2 id="控制端"><a href="#控制端" class="headerlink" title="控制端:"></a>控制端:</h2><p><img src="http://i1.piimg.com/567571/c39e41ea7ca885d2.jpg" alt="控制端的样式"><br>下面放代码:</p>
<pre><code>#import &quot;ViewController.h&quot;
#import &quot;AsyncUdpSocket.h&quot;
#include &lt;ifaddrs.h&gt;
#include &lt;arpa/inet.h&gt;

@interface ViewController (){
  AsyncUdpSocket *_socket;
NSString *_ipAddress;
}

@property (nonatomic,strong)UITextField *tf;

@end

@implementation ViewController

- (void)viewDidLoad {
[super viewDidLoad];

//输入框
_tf = [[UITextField alloc] initWithFrame:CGRectMake(20, 100, 200, 50)];
_tf.backgroundColor = [UIColor grayColor];
[self.view addSubview:_tf];

//获取ip地址
_ipAddress = [self deviceIPAdress];
NSLog(@&quot;%@&quot;,_ipAddress);

UIButton *but = [[UIButton alloc] initWithFrame:CGRectMake(200, 200, 80, 30)];
[but setBackgroundColor:[UIColor redColor]];
[but setTitle:@&quot;发送&quot; forState:UIControlStateNormal];
[but addTarget:self action:@selector(sendTheNumber) forControlEvents:UIControlEventTouchUpInside];
[self.view addSubview:but];
}
</code></pre><p>//初始化socket和发送ip</p>
<pre><code>- (void)sendTheNumber{
_socket = [[AsyncUdpSocket alloc]initIPv4];
_socket.delegate = self;
//ip 和 端口号
[_socket bindToAddress:_ipAddress port:9444 error:nil];

//[_socket sendData:data toAddress:@&quot;192.168.1.160&quot; withTimeout:-1 tag:0];

NSData* data = [_tf.text dataUsingEncoding:NSUTF8StringEncoding];

[_socket sendData:data toHost:@&quot;10.10.5.38&quot; port:9444 withTimeout:-1 tag:0];

_tf.text = @&quot;&quot;;
//保持连接
[_socket receiveWithTimeout:-1 tag:0];
}

- (BOOL)onUdpSocket:(AsyncUdpSocket *)sock didReceiveData:(NSData *)data withTag:(long)tag fromHost:(NSString *)host port:(UInt16)port{

return YES;
</code></pre><p>}</p>
<pre><code>//wifi下获取手机ip的方法

- (NSString *)deviceIPAdress {
NSString *address = @&quot;an error occurred when obtaining ip address&quot;;
struct ifaddrs *interfaces = NULL;
struct ifaddrs *temp_addr = NULL;
int success = 0;

success = getifaddrs(&amp;interfaces);

if (success == 0) { // 0 表示获取成功

    temp_addr = interfaces;
    while (temp_addr != NULL) {
        if( temp_addr-&gt;ifa_addr-&gt;sa_family == AF_INET) {
            // Check if interface is en0 which is the wifi connection on the iPhone
            if ([[NSString stringWithUTF8String:temp_addr-&gt;ifa_name] isEqualToString:@&quot;en0&quot;]) {
                // Get NSString from C String
                address = [NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)temp_addr-&gt;ifa_addr)-&gt;sin_addr)];
            }
        }

        temp_addr = temp_addr-&gt;ifa_next;
    }
}

freeifaddrs(interfaces);

NSLog(@&quot;手机的IP是：%@&quot;, address);
return address;
</code></pre><p>}</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">


      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/child/2016/12/01/webView和tableView的混排/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="hapii">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://tva1.sinaimg.cn/crop.0.14.750.750.180/005PluWajw8fahgdnankoj30ku0lnjsd.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="不要急，不要怕">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="不要急，不要怕" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/01/webView和tableView的混排/" itemprop="url">
                  webView和tableView的混排
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-01T11:18:15+08:00">
                2016-12-01
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/12/01/webView和tableView的混排/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/01/webView和tableView的混排/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/12/01/webView和tableView的混排/" class="leancloud_visitors" data-flag-title="webView和tableView的混排">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>类似于近日头条的上边是webView，下边是推荐的tableView效果.<br><img src="http://p1.bpimg.com/567571/41d03799238bb66c.gif" alt="先看一下效果图"><br>首先说一下tableView和WebView的嵌套方法，试了好多种，感觉这个比较好    <a href="http://www.jianshu.com/p/4658d68cf280" target="_blank" rel="external">原文链接：</a></p>
<h2 id="点击cell刷新cell"><a href="#点击cell刷新cell" class="headerlink" title="点击cell刷新cell:"></a>点击cell刷新cell:</h2><p>点击cell后要查看新的内容，首先在tableView didSelectRowAtIndexPath里对请求网址的变量重新赋值,id啦，url之类的，然后移除视图中所有的View</p>
<pre><code>for(UIView *view in [self.view subviews]){
       [view removeFromSuperview];
   }
</code></pre><p>记得移除观察者，因为要观察的对象已经没了。</p>
<p>然后把搭建页面请求数据的方法重写一遍</p>
<pre><code> [self createUI];
//[self createReturnBut];
[self loadDataisFresh:NO];//请求数据
//注册
[self registerNibTableViewCell];
//加载数据
[self requestByUrl:self.loadUrl];
</code></pre><p>这里要记得在注册一次观察者，我把他放到了createUI这个方法里</p>
<pre><code>[self.webView.scrollView addObserver:self forKeyPath:@&quot;contentSize&quot; options:NSKeyValueObservingOptionOld | NSKeyValueObservingOptionNew context:nil];
</code></pre><p>刷新tableView</p>
<pre><code>[self.tb reloadData];
</code></pre><p>对了，在定义一个全局变量，记录webView的高度，用于点击跳到头部</p>
<pre><code>@property (nonatomic,assign)CGFloat webViewHeight;
</code></pre><p>在- (void)observeValueForKeyPath:方法中给他赋值</p>
<pre><code> CGRect frame = self.webView.frame;
 frame.size.height = self.webView.scrollView.contentSize.height;
 //这里获取webView的高度
_webViewHeight = frame.size.height;
</code></pre><p>最后回到tableView didSelectRowAtIndexPath:点击方法中,跳到顶部,tableView的高度减去webView的高度</p>
<pre><code>[self.tb setContentOffset:CGPointMake(0, -_webViewHeight) animated:YES];
</code></pre><p> 让tableView滚回到最顶端。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">


      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/child/2016/11/25/iOS提示版本更新/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="hapii">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://tva1.sinaimg.cn/crop.0.14.750.750.180/005PluWajw8fahgdnankoj30ku0lnjsd.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="不要急，不要怕">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="不要急，不要怕" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/25/iOS提示版本更新/" itemprop="url">
                  iOS提示版本更新
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-25T12:19:02+08:00">
                2016-11-25
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/11/25/iOS提示版本更新/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/25/iOS提示版本更新/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/11/25/iOS提示版本更新/" class="leancloud_visitors" data-flag-title="iOS提示版本更新">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一：在某个服务器上存储最新发布的版本信息，需要的时候向该服务器查询；<br>二：在需要的时候向 appstore 查询</p>
<p>方法一就不多说了，个人感觉还是法二好一些，更新及时，自己就搞定了，不用和后台交流。</p>
<h2 id="请求"><a href="#请求" class="headerlink" title="请求:"></a>请求:</h2><p>get请求 这个地址<a href="http://itunes.apple.com/lookup?id=你的appid" target="_blank" rel="external">http://itunes.apple.com/lookup?id=你的appid</a><br>之后我们会得到一个的json数据，里面包含着我们好多的app各种信息，这里我删了好多.<br> {<br>    resultCount = 1;<br>    results =     (<br>                {<br>            advisories =             (<br>            );</p>
<pre><code>        features =             (
        );
        fileSizeBytes = 14362624;
        formattedPrice = Free;
        genreIds =             (
            6009,
            6002
        );
        genres =             (
            News,
            Utilities
        );

        trackName = &quot;\U9ed4\U897f\U5357\U624b\U673a\U53f0&quot;;
        trackViewUrl = &quot;https://itunes.apple.com/us/app/qian-xi-nan-shou-ji-tai/id786874960?mt=8&amp;uo=4&quot;;
        version = &quot;1.5.4&quot;;
        wrapperType = software;
    }
);
</code></pre><p>}</p>
<p>用如下的方法的到app的版本信息，先得到results数组：</p>
<pre><code>NSArray *infoArray = [responseObject objectForKey:@&quot;results&quot;];
</code></pre><p>取第一个字典：</p>
<pre><code>NSDictionary *releaseInfo = [infoArray objectAtIndex:0];
</code></pre><p>得到当前版本号以及app的下载地址：</p>
<pre><code>NSString *latestVersion = [releaseInfo objectForKey:@&quot;version&quot;];
NSString *trackViewUrl = [releaseInfo objectForKey:@&quot;trackViewUrl&quot;];
</code></pre><p>但是注意这个方法不要每次去执行，没有必要，最好是一天的某个时间执行一次，</p>
<p>得到版本号，</p>
<pre><code>NSString* localVersion =  [[NSBundle mainBundle] infoDictionary][@&quot;CFBundleVersion&quot;];
</code></pre><h2 id="比较app版本号"><a href="#比较app版本号" class="headerlink" title="比较app版本号:"></a>比较app版本号:</h2><pre><code>if ([latestVersion compare:localVersion options:NSNumericSearch] == NSOrderedDescending) {
    NSLog(@&quot;%@ is bigger&quot;,latestVersion);
  //弹出提示框，是否下载
}else
{
    NSLog(@&quot;%@ is bigger&quot;,localVersion);
}
</code></pre><h2 id="跳转下载"><a href="#跳转下载" class="headerlink" title="跳转下载:"></a>跳转下载:</h2><p>如果大于则弹出提示框，提示用户是否前往下载，前往下载的话，用openURL直接跳转到了appStore上（同样，给好评等也是通过这个方法）</p>
<pre><code>[[UIApplication sharedApplication] openURL:[NSURL URLWithString:trackViewUrl]];
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">


      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/child/2016/11/18/PHAsset/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="hapii">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://tva1.sinaimg.cn/crop.0.14.750.750.180/005PluWajw8fahgdnankoj30ku0lnjsd.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="不要急，不要怕">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="不要急，不要怕" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/18/PHAsset/" itemprop="url">
                  PhotoKit
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-18T11:05:28+08:00">
                2016-11-18
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/11/18/PHAsset/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/18/PHAsset/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/11/18/PHAsset/" class="leancloud_visitors" data-flag-title="PhotoKit">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于项目重构，将图片选择器重<a href="https://github.com/chiunam/CTAssetsPickerController" target="_blank" rel="external">CTAssetsPickerController</a>换成了<a href="https://github.com/banchichen/TZImagePickerController" target="_blank" rel="external">TZImagePickerController</a>，两者都是优秀的图片选择器，但我个人更喜欢后者（因为有中午说明～～）。</p>
<p>换完之后发现视频上传功能出问题了，原来以前的上传方法是用ALAssetsLibrary上传的，但是看TZImagePickerController发现8以后就使用的Photos Framework。</p>
<pre><code>// If user picking a video, this handle will be called.
// If system version &gt; iOS8,asset is kind of PHAsset class, else is ALAsset class.
// 如果用户选择了一个视频，下面的handle会被执行
// 如果系统版本大于iOS8，asset是PHAsset类的对象，否则是ALAsset类的对象
@property (nonatomic, copy) void (^didFinishPickingVideoHandle)(UIImage *coverImage,id asset);
</code></pre><p>这是以前上传的两种方法，</p>
<pre><code>ALAsset *asset = [mediaDatas objectAtIndexSafe:0];
NBLog(@&quot;asset=%@, representation=%@, url=%@&quot;, asset, [asset defaultRepresentation], [asset defaultRepresentation].url);

 if (asset != nil) {

    if (/* DISABLES CODE */ (1)) {
        NSString *videoPath = [NSDocumentsPath stringByAppendingPathComponent:[NSString stringWithFormat:@&quot;%d.mov&quot;, 0]];    // 这里直接强制写一个即可，之前计划是用i++来区分不明视频
        //可以看出来使用fileURLWithPath创建出来的URL会自动加上协议头
        NSURL *url = [NSURL fileURLWithPath:videoPath];
        NSError *theErro = nil;
        BOOL exportResult = [asset exportDataToURL:url error:&amp;theErro];
        NBLog(@&quot;exportResult=%@&quot;, exportResult?@&quot;YES&quot;:@&quot;NO&quot;);

        NSData *videoData = [NSData dataWithContentsOfURL:url];
        //      NSData *videoData = [NSData dataWithContentsOfFile:videoPath];
        //                                        [formData appendPartWithFormData:videoData name:@&quot;video1&quot;];
        //第一个参数是服务器存你上传视频的文件夹名，第二个参数是你上传视频的名字，随便写。第三个是格式。
        [formData appendPartWithFileData:videoData name:@&quot;video1&quot; fileName:@&quot;video1.mov&quot; mimeType:@&quot;video/quicktime&quot;];

    }else {

        //第一种获取NSData的方式， 上传后， 后台仅获取到文本
        //ALAssetRepresentation获取本地相册
        ALAssetRepresentation *rep = [asset defaultRepresentation];
        Byte *buffer = (Byte*)malloc(rep.size);
        NSUInteger buffered = [rep getBytes:buffer fromOffset:0.0 length:rep.size error:nil];
        NSData *videoData = [NSData dataWithBytesNoCopy:buffer length:buffered freeWhenDone:YES];
        //传到服务器
        //[formData appendPartWithFormData:videoData name:@&quot;video1&quot;];
        [formData appendPartWithFileData:videoData name:@&quot;video1&quot; fileName:@&quot;video1&quot; mimeType:@&quot;video/quicktime&quot;];
     }

    NBLog(@&quot;method 2&quot;);
}
</code></pre><p>点开ALAssetsLibrary，发现人性化的🍎早已为你写好了新方法<br><img src="http://i1.piimg.com/567571/20f5db8f656beaeb.png" alt="ALAssetsLibrary的方法"><br> 新方法:</p>
<pre><code>PHAsset *asset = [mediaDatas objectAtIndexSafe:0];

 [[PHImageManager defaultManager] requestImageDataForAsset:asset options:nil resultHandler:^(NSData * _Nullable imageData, NSString * _Nullable dataUTI, UIImageOrientation orientation, NSDictionary * _Nullable info) {
                         [formData appendPartWithFileData:imageData name:@&quot;video1&quot; fileName:@&quot;video1&quot; mimeType:@&quot;video/quicktime&quot;];
                   }];
</code></pre><p>由于现在项目最低8.0，所以就不做ALAssetsLibrary的方法的了。<br>好了，下面该说一说PHAsset了。</p>
<hr>
<h2 id="PHAsset"><a href="#PHAsset" class="headerlink" title="PHAsset:"></a>PHAsset:</h2><p><strong>PHAsset</strong>: 代表照片库中的一个资源，跟 ALAsset 类似，通过 PHAsset 可以获取和保存资源<br><strong>PHFetchOptions</strong>: 获取资源时的参数，可以传 nil，即使用系统默认值</p>
<pre><code>//做选择的约束条件。比如，只获取图片，不获取视频。
 phopt.predicate = [NSPredicate predicateWithFormat:@&quot;mediaType == %d&quot;,PHAssetMediaTypeImage];//只取图片

//按可指定字段用来对获取结果进行排序
phopt.sortDescriptors = @[[NSSortDescriptor sortDescriptorWithKey:@&quot;creationDate&quot; ascending:YES]]; // 按图片生成时间排序
phopt.includeHiddenAssets = YES;//获取结果是否包括被隐藏的资源
phopt.includeAllBurstAssets = YES;//获取结果是否包括连拍资源
phopt.wantsIncrementalChangeDetails = YES;//允许变化细节？
</code></pre><p><strong>PHFetchResult</strong>: 表示一系列的资源集合，也可以是相册的集合，可以用类似 NSArray 的接口来访问PHFetchResult结果内的集合。</p>
<pre><code>PHFetchResult *albums = [PHAssetCollection fetchAssetCollectionsWithType:PHAssetCollectionTypeSmartAlbum subtype:PHAssetCollectionSubtypeSmartAlbumAllHidden options:nil];
</code></pre><p><strong>PHAssetCollection</strong>: 表示一个相册或者一个时刻，或者是一个「智能相册（系统提供的特定的一系列相册，例如：最近删除，视频列表，收藏等等）,下面是一些只读属性</p>
<p>######assetCollectionType 资源集合类型，比如相册或者“时刻”相册，</p>
<pre><code>enum PHAssetCollectionType : Int {

case Album //从 iTunes 同步来的相册，以及用户在 Photos 中自己建立的相册
case SmartAlbum //经由相机得来的相册
case Moment //Photos 为我们自动生成的时间分组的相册

}
</code></pre><p>######assetCollectionSubtype 子类型</p>
<pre><code>  enum PHAssetCollectionSubtype : Int {
case AlbumRegular //用户在 Photos 中创建的相册
case AlbumSyncedEvent //使用 iTunes 从 Photos 照片库或者 iPhoto 照片库同步过来的事件。然而，在iTunes 12 以及iOS 9.0 beta4上，选用该类型没法获取同步的事件相册，而必须使用AlbumSyncedAlbum。
case AlbumSyncedFaces //使用 iTunes 从 Photos 照片库或者 iPhoto 照片库同步的人物相册。
case AlbumSyncedAlbum //做了 AlbumSyncedEvent 应该做的事
case AlbumImported //从相机或是外部存储导入的相册，完全没有这方面的使用经验，没法验证。
case AlbumMyPhotoStream //用户的 iCloud 照片流
case AlbumCloudShared //用户使用 iCloud 共享的相册
case SmartAlbumGeneric //文档解释为非特殊类型的相册，主要包括从 iPhoto 同步过来的相册。
case SmartAlbumPanoramas //相机拍摄的全景照片
case SmartAlbumVideos //相机拍摄的视频
case SmartAlbumFavorites //收藏文件夹
case SmartAlbumTimelapses //延时视频文件夹，同时也会出现在视频文件夹中
case SmartAlbumAllHidden //包含隐藏照片或视频的文件夹
case SmartAlbumRecentlyAdded //相机近期拍摄的照片或视频
case SmartAlbumBursts //连拍模式拍摄的照片
case SmartAlbumUserLibrary //这个命名最神奇了，就是相机相册，所有相机拍摄的照片或视频都会出现在该相册中，而且使用其他应用保存的照片也会出现在这里。
case Any //包含所有类型

}
</code></pre><p>######estimatedAssetCount ：估算的asset数量，不精确</p>
<p><strong>PHImageManager</strong>: 用于处理资源的加载，加载图片的过程带有缓存处理，可以通过传入一个 PHImageRequestOptions 控制资源的输出尺寸等规格，在框架中是个单例对象，用[PHImageManager defaultManager]获取,它提供了加载图片和视频的方法,</p>
<p><strong>PHImageRequestOptions</strong>: 如上面所说，控制加载图片时的一系列参数</p>
<pre><code> PHImageRequestOptions  *options= [PHImageRequestOptions new];
 //这个属性是指获取的图像是否需要包含系统相册“编辑”功能处理过的信息（如滤镜，旋转等）
options.version = PHImageRequestOptionsVersionCurrent;
options.deliveryMode = PHImageRequestOptionsDeliveryModeHighQualityFormat;
/*
 PHImageRequestOptionsDeliveryModeOpportunistic = 0,图片获取速度和质量的平衡
 PHImageRequestOptionsDeliveryModeHighQualityFormat = 1,高质量图片,
 PHImageRequestOptionsDeliveryModeFastFormat = 2 快速得到图片的情况下保证质量
 */

options.resizeMode = PHImageRequestOptionsResizeModeExact;
/*
 PHImageRequestOptionsResizeModeNone = 0,不压缩
 PHImageRequestOptionsResizeModeFast,高效率请求,但是返回的图片尺寸可能和要求的尺寸不同
 PHImageRequestOptionsResizeModeExact,按照精准尺寸返回
 */

// 同步获得图片, 只会返回1张图片,PS: 若options.synchronous = YES,则不论options.deliveryMode如何设置,系统会选择PHImageRequestOptionsDeliveryModeHighQualityFormat(高质量图片)
options.synchronous = YES;
//是否联网获取iCloud的图片
options.networkAccessAllowed = NO;
//指定作物矩形单元坐标的原始图像,如的脸。默认为CGRectZero(不适用)
options.normalizedCropRect = CGRectMake(100, 200, 100, 100);

options.progressHandler
//一个 PHAssetImageProgressHandler 的 block，当从 iCloud 下载照片时，它就会被图像管理器自动调用还有一个与 iCloud 密切相关的属性当图像需要从 iCloud 下载时，这个 block 会被自动调用，block 中会返回图像下载的进度，图像的信息，出错信息。开发者可以利用这些信息反馈给用户当前图像的下载进度以及状况，但需要注意?progressHandler 不在主线程上执行，因此在其中需要操作 UI，则需要手工放到主线程执行。
options.progressHandler
</code></pre><p><a href="http://kayosite.com/ios-development-and-detail-of-photo-framework-part-two.html" target="_blank" rel="external">更详细的戳这里</a></p>
<p><a href="https://objccn.io/issue-21-4/" target="_blank" rel="external">这个翻译也很直白</a></p>
<p>当然，还有PHImageCachingManager 用于处理图像的缓存这里就不说了～～<br>最后，挂个图：<br><img src="http://kayosite.com/wp-content/uploads/2015/09/ios8-photo-kit.png" alt="PhotoKit构成"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">


      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/child/2016/11/11/runtime初体验-关联/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="hapii">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://tva1.sinaimg.cn/crop.0.14.750.750.180/005PluWajw8fahgdnankoj30ku0lnjsd.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="不要急，不要怕">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="不要急，不要怕" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/11/runtime初体验-关联/" itemprop="url">
                  runtime初体验--关联
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-11T16:46:40+08:00">
                2016-11-11
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/11/11/runtime初体验-关联/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/11/runtime初体验-关联/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/11/11/runtime初体验-关联/" class="leancloud_visitors" data-flag-title="runtime初体验--关联">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对象关联（或称为关联引用）本来是Objective-C 2.0运行时的一个特性，起始于OS X Snow Leopard和iOS 4。相关参考可以查看 <objc runtime.h=""> 中定义的以下三个允许你将任何键值在运行时关联到对象上的函数：</objc></p>
<p>objc_setAssociatedObject<br>objc_getAssociatedObject<br>objc_removeAssociatedObjects</p>
<p>他可以将某个OC对象通过一个唯一的key连接到一个类的实例上，这允许开发者对已经存在的类在扩展中添加自定义的属性，这几乎弥补了Objective-C最大的缺点。</p>
<h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子:"></a>举个栗子:</h2><p>首先，引入#import <objc runtime.h=""></objc></p>
<p>创建一个View<br>     UIView *view = [[UIView alloc]initWithFrame:CGRectMake(40,40 ,10 , 10)];<br> 创建一个移动手势：</p>
<pre><code>self.pan = [[UIPanGestureRecognizer alloc]initWithTarget:self action:@selector(panGesture:)];
</code></pre><p>将view和 颜色这两个属性添加到手势这个对象上：</p>
<pre><code>typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {
OBJC_ASSOCIATION_ASSIGN = 0,           /**&lt; Specifies a weak reference to the associated object. */
OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object. 
                                        *   The association is not made atomically. */
OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**&lt; Specifies that the associated object is copied. 
                                        *   The association is not made atomically. */
OBJC_ASSOCIATION_RETAIN = 01401,       /**&lt; Specifies a strong reference to the associated object.
                                        *   The association is made atomically. */
OBJC_ASSOCIATION_COPY = 01403          /**&lt; Specifies that the associated object is copied.
                                        *   The association is made atomically. */
};    
</code></pre><p>这里objc_AssociationPolicy是一个枚举类型的数据结构定义了OBJC_ASSOCIATION_ASSIGN、OBJC_ASSOCIATION_RETAIN_NONATOMIC、OBJC_ASSOCIATION_COPY_NONATOMIC、<br>OBJC_ASSOCIATION_RETAIN和<br>OBJC_ASSOCIATION_COPY这样五个关联对象特性，每个特性的描述如下：</p>
<p>OBJC_ASSOCIATION_ASSIGN,给关联对象指定弱引用,相当于@property(assign)或@property(unsafe_unretained)</p>
<p>OBJC_ASSOCIATION_RETAIN_NONATOMIC,给关联对象指定非原子的强引用,相当于@property(nonatomic,strong)或@property(nonatomic,retain)</p>
<p>OBJC_ASSOCIATION_COPY_NONATOMIC,给关联对象指定非原子的copy特性,相当于@property(nonatomic,copy)</p>
<p>OBJC_ASSOCIATION_RETAIN,给关联对象指定原子强引用,相当于@property(atomic,strong)或@property(atomic,retain)</p>
<p>OBJC_ASSOCIATION_COPY,给关联对象指定原子copy特性,相当于@property(atomic,copy)</p>
<pre><code>objc_setAssociatedObject(self.pan, &quot;firstObject&quot;, view, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
objc_setAssociatedObject(self.pan, &quot;secondObject&quot;, view.backgroundColor, OBJC_ASSOCIATION_RETAIN_NONATOMIC); OBJC_ASSOCIATION_RETAIN_NONATOMIC);
</code></pre><p>在手势移动的方法-(void)panGesture:(UIPanGestureRecognizer *)pan中实现：</p>
<pre><code>UIView *view = objc_getAssociatedObject(pan, &quot;firstObject&quot;);
    UIColor *color = objc_getAssociatedObject(pan, &quot;secondObject&quot;);
     objc_removeAssociatedObjects(pan);
</code></pre><p>这样就的到了两个属性。什么，通过view.backgroundcolor就可以直接得到这两个属性了？只是个例子，目的是要看懂！！get,set有没有很熟悉呢？</p>
<p>需要注意的是objc_removeAssociatedObjects 函数我们一般是用不上的，因为这个函数会移除一个对象的所有关联对象，将该对象恢复成“原始”状态。这样做就很有可能把别人添加的关联对象也一并移除，这并不是我们所希望的。所以一般的做法是通过给 objc_setAssociatedObject 函数传入 nil 来移除某个已有的关联对象。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">


      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/child/2016/11/10/cell的复用/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="hapii">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://tva1.sinaimg.cn/crop.0.14.750.750.180/005PluWajw8fahgdnankoj30ku0lnjsd.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="不要急，不要怕">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="不要急，不要怕" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/10/cell的复用/" itemprop="url">
                  cell的复用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-10T11:20:09+08:00">
                2016-11-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/11/10/cell的复用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/10/cell的复用/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/11/10/cell的复用/" class="leancloud_visitors" data-flag-title="cell的复用">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="cell创建的几种方式"><a href="#cell创建的几种方式" class="headerlink" title="cell创建的几种方式:"></a>cell创建的几种方式:</h2><p>1.最常见的方法:</p>
<pre><code>NoDataTbViewCell *cell =[tableView dequeueReusableCellWithIdentifier:@&quot;noDataCell&quot;];
    cell.delegate = self;
   if (cell==nil) {
       cell = [[NoDataTbViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@&quot;noDataCell&quot;];
   }
   return cell;
</code></pre><p>2.注册：<br>先在给tableView设置delegate之前注册cell：    </p>
<pre><code>xib的：[self.tableView registerNib:[UINib nibWithNibName:NSStringFromClass([VideoTableViewCell class]) bundle:nil] forCellReuseIdentifier:VideoCell];

代码的： [self.tableView registerClass:[VideoTableViewCell class] forCellReuseIdentifier:VideoCell];
</code></pre><p>然后 cellForRowAtIndexPath:里</p>
<pre><code>VideoTableViewCell *cell  = [tableView dequeueReusableCellWithIdentifier:identifier];
</code></pre><p>3.xib本地加载：</p>
<pre><code>VideoTableViewCell *cell           = [tableView dequeueReusableCellWithIdentifier:identifier ];
   if (cell==nil) {
       cell = [[[NSBundle mainBundle] loadNibNamed:@&quot;VideoTableViewCell&quot; owner:self options:nil] lastObject];
       }    
</code></pre><h2 id="cell复用原理"><a href="#cell复用原理" class="headerlink" title="cell复用原理:"></a>cell复用原理:</h2><p>说起复用就必须要说一下dequeueReusableCellWithIdentifier:这个函数，在iOS 6中dequeueReusableCellWithIdentifier:被dequeueReusableCellWithIdentifier:forIndexPath:所取代。如此一来，在表格视图中创建并添加UITableViewCell对象会变得更为精简而流畅。而且使用dequeueReusableCellWithIdentifier:forIndexPath:一定会返回cell，系统在默认没有cell可复用的时候会自动创建一个新的cell出来。但是使用dequeueReusableCellWithIdentifier:forIndexPath:的话，必须要和注册配合使用</p>
<p>dequeueReusableCellWithIdentifier消息返回的是UITableViewCell对象，即是说这是一个用来获取UITableViewCell对象的消息，之所以不说是初始化一个对象，是因为它可能返回nil值，所以才要在下面补充一个如果cell为nil时的处理过程。</p>
<p>那么这个方法是不是可以解释成为，从一个UITableViewCell对象池中获取一个以Identifier参数命名的UITableViewCell对象。<br>如果在资源紧缺的时候，这个池会自动清理多余的UITableViewCell对象，则可能无法返回对象，但如果资源丰富，则会保存一些UITableViewCell对象，在需要调用的时候迅速的返回，而不用创建。</p>
<p>dequeueReusableCellWithIdentifier，从字面上理解是“出列的可重用的cell”，其实简单说就是一个cell池，里面放的就是你之前创建过的cell。使用时要注意：<br>1。重取出来的cell是有可能已经捆绑过数据或者加过子视图的，所以，如果有必要，要清除数据（比如textlabel的text）和remove掉add过的子视图（使用tag。所以在给cell的模型赋值的时候一些逻辑最好放在if（cell==nil）里去执行.<br>2。这样设计的目的是为了避免频繁的 alloc和delloc cell对象而已,没有多复杂。<br>3。设计的关键是实现cell和数据的完全分离</p>
<p>关键点在”一个屏幕显示的cell数量”是有限的<br>当屏幕滚动时候，就会调用方法获取新的cell，而老的cell会在屏幕外面就不显示了</p>
<p>reuse机制就是这样。当cell需要显示的时候，从queue里面找，找到了，设置一下内容，显示出来<br>滚动界面当有cell被移出屏幕时，把这个cell丢到queue里面<br>显示新的cell时，如果有“相同类型”(identifier)的cell，就从队列拿一个出来，设置数据，显示出来<br>至于queue里面会有多少cell，这个会自动控制</p>
<p>要注意的是，queue里面存储的是cell的实例，不是“原型”<br>因此就会出现上面说的“假设每页有 5个。 则 第6个复用第1个cell； 第7个复用第2个；”<br>这样的结果是不管你的table有多少行，内存里实际上都只需要存储一个屏幕那么多行的cell就搞定了。。</p>
<p><a href="http://blog.csdn.net/dong_007_007/article/details/7580392" target="_blank" rel="external">部分链接</a></p>
<h2 id="tableView的执行过程"><a href="#tableView的执行过程" class="headerlink" title="tableView的执行过程:"></a>tableView的执行过程:</h2><p>调用numberOfSection获得 A个 section<br>先调用numberOfRowsInSection获得B个cell,再调用heightForRowB次。如此循环A次<br>循环调用cellForRow和heightForRow，直到cell的个数充满当前屏幕。</p>
<p><img src="http://images2015.cnblogs.com/blog/527522/201607/527522-20160727174550903-992232741.png" alt="附tableView代理方法表"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">


      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/child/2016/11/04/下AFN大量爆红/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="hapii">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://tva1.sinaimg.cn/crop.0.14.750.750.180/005PluWajw8fahgdnankoj30ku0lnjsd.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="不要急，不要怕">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="不要急，不要怕" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/04/下AFN大量爆红/" itemprop="url">
                  leaks下AFN大量爆红
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-04T11:11:27+08:00">
                2016-11-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/日常Bug/" itemprop="url" rel="index">
                    <span itemprop="name">日常Bug</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/11/04/下AFN大量爆红/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/04/下AFN大量爆红/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/11/04/下AFN大量爆红/" class="leancloud_visitors" data-flag-title="leaks下AFN大量爆红">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>leaks是Xcode的Instruments里面有一个Leaks工具，可以帮助你定位发生内存泄漏的代码段，以便修复问题。是一个非常好用的工具。使用方法(更详细的自行百度或<a href="http://www.jianshu.com/p/c0aa12d91f05" target="_blank" rel="external">点这里</a>)：<br>1.先点开这个<br><img src="http://7xrn7f.com1.z0.glb.clouddn.com/16-11-4/44034669.jpg" alt="1.先点开这个"></p>
<p>2.然后选择了这个<br><img src="http://7xrn7f.com1.z0.glb.clouddn.com/16-11-4/63840634.jpg" alt="2.然后选择了这个"><br>3.点击到旁边的设置，把这几个点了<br><img src="http://7xrn7f.com1.z0.glb.clouddn.com/16-11-4/7238907.jpg" alt="3.点击到旁边的设置，把这几个点了"><br>4.选择设备，点击红点运行<br><img src="http://7xrn7f.com1.z0.glb.clouddn.com/16-11-4/36329608.jpg" alt="4.选择设备，点击红点运行"><br>5.上边点击到leaks，在把2点到call Tree看效果<br><img src="http://7xrn7f.com1.z0.glb.clouddn.com/16-11-4/53899911.jpg" alt="5.上边点击到leaks，在把2点到call Tree看效果"><br>爆红的话直接双击上图的代码，一般就会跳到对应的泄漏代码段，但是如果是跳到了汇编语言是什么鬼呢？（我也不知道，，，）<br>上图运行结果发现大部分都是AFN内存泄漏。。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法:"></a>解决办法:</h2><p><a href="http://www.jianshu.com/p/85b34695df15" target="_blank" rel="external">这位大哥说的很详细，我就是按他的办法来的</a><br>详细方法：点击这个函数<br><code>AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</code><br>以前是这样的：<br><code>+ (instancetype)manager {
    return [[[self class] alloc] initWithBaseURL:nil];
}</code><br>然后我把它改成了这样的：<br><code>+ (instancetype)manager {
    //wq瞎j8改，把它改成单例
    static AFHTTPSessionManager *manager = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        if (manager == nil) {
            manager = [[[self class] alloc] initWithBaseURL:nil];
        }
    });
    return manager;
}</code></p>
<p>嗯，AFN果然没啦!<br><img src="http://7xrn7f.com1.z0.glb.clouddn.com/16-11-4/33327271.jpg" alt="结果"></p>
<p>ps：暂时没有发现有什么问题，测试几天看看。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">


      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/child/2016/10/31/iOS动画学习，持续更新ing/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="hapii">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://tva1.sinaimg.cn/crop.0.14.750.750.180/005PluWajw8fahgdnankoj30ku0lnjsd.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="不要急，不要怕">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="不要急，不要怕" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/31/iOS动画学习，持续更新ing/" itemprop="url">
                  iOS动画学习，持续更新ing...
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-10-31T14:47:45+08:00">
                2016-10-31
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/10/31/iOS动画学习，持续更新ing/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/10/31/iOS动画学习，持续更新ing/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/10/31/iOS动画学习，持续更新ing/" class="leancloud_visitors" data-flag-title="iOS动画学习，持续更新ing...">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="CAEmitterLayer"><a href="#CAEmitterLayer" class="headerlink" title="CAEmitterLayer:"></a>CAEmitterLayer:</h2><p>######CAEmitterLayer继承于 CALayer是一个高性能的粒子引擎，被用来创建实时例子动画如：烟雾，火，雨等等这些效果。 </p>
<p>######CAEmitterLayer看上去像是许多CAEmitterCell的容器，这些CAEmitierCell定义了一个例子效果。你将会为不同的例子效果定义一个或多个CAEmitterCell作为模版，同时CAEmitterLayer负责基于这些模版实例化一个粒子流。一个CAEmitterCell类似于一个CALayer：它有一个contents属性可以定义为一个CGImage，另外还有一些可设置属性控制着表现和行为。我们不会对这些属性逐一进行详细的描述，你们可以在CAEmitterCell类的头文件中找到。<br>雪花动画：</p>
<ul>
<li><p>(void)createSnow{</p>
<p> self.view.backgroundColor  = [UIColor blackColor];</p>
<p>// 创建粒子Layer<br>CAEmitterLayer *snowEmitter = [CAEmitterLayer layer];</p>
<p>// 粒子发射位置<br>snowEmitter.emitterPosition = CGPointMake(120,20);</p>
<p>// 发射源的尺寸大小<br>snowEmitter.emitterSize = self.view.bounds.size;</p>
<p>// 发射模式<br>snowEmitter.emitterMode = kCAEmitterLayerSurface;</p>
<p>// 发射源的形状<br>snowEmitter.emitterShape = kCAEmitterLayerLine;</p>
<p>// 创建雪花类型的粒子<br>CAEmitterCell *snowflake = [CAEmitterCell emitterCell];</p>
<p>// 粒子的名字<br>snowflake.name = @”snow”;</p>
<p>// 粒子参数的速度乘数因子<br>snowflake.birthRate = 1.0;<br>snowflake.lifetime = 120.0;</p>
<p>// 粒子速度<br>snowflake.velocity =10.0;</p>
<p>// 粒子的速度范围<br>snowflake.velocityRange = 10;</p>
<p>// 粒子y方向的加速度分量<br>snowflake.yAcceleration = 2;</p>
<p>// 周围发射角度<br>snowflake.emissionRange = 0.5 * M_PI;</p>
<p>// 子旋转角度范围<br>snowflake.spinRange = 0.25 * M_PI;<br>snowflake.contents = (id)[[UIImage imageNamed:@”snow”] CGImage];</p>
<p>// 设置雪花形状的粒子的颜色<br>snowflake.color = [[UIColor whiteColor] CGColor];</p>
<p>snowflake.scaleRange = 0.6f;<br>snowflake.scale = 0.7f;</p>
<p>snowEmitter.shadowOpacity = 1.0;<br>snowEmitter.shadowRadius = 0.0;<br>snowEmitter.shadowOffset = CGSizeMake(0.0, 0.0);</p>
<p>// 粒子边缘的颜色<br>snowEmitter.shadowColor = [[UIColor whiteColor] CGColor];</p>
<p>// 添加粒子<br>snowEmitter.emitterCells = @[snowflake];</p>
<p>// 将粒子Layer添加进图层中<br>[self.view.layer addSublayer:snowEmitter];</p>
</li>
</ul>
<p>}</p>
<p>烟花动画：</p>
<ul>
<li><p>(void)createFire{</p>
<p>  self.view.backgroundColor  = [UIColor blackColor];</p>
<p>  //创建粒子<br>  CAEmitterLayer *fireworksEmitter = [CAEmitterLayer layer];<br>  //取个坐标系<br>  CGRect viewBounds = self.view.layer.bounds;</p>
</li>
</ul>
<pre><code>// 粒子发射位置
fireworksEmitter.emitterPosition = \
CGPointMake(viewBounds.size.width/2.0, viewBounds.size.height);
// 周围发射大小
fireworksEmitter.emitterSize    = CGSizeMake(viewBounds.size.width/2.0, 0.0);
// 周围发射角度
fireworksEmitter.emitterMode    = kCAEmitterLayerOutline;

 //常用的产生粒子模式 三种kCAEmitterLayerPoint 点 kCAEmitterLayerLine线 kCAEmitterLayerRectangle 矩形
fireworksEmitter.emitterShape    = kCAEmitterLayerLine;


fireworksEmitter.renderMode      = kCAEmitterLayerAdditive;

//用于初始化随机数生成的
fireworksEmitter.seed = (arc4random()%100)+1;

// Create the rocket
CAEmitterCell * rocket = [CAEmitterCell emitterCell];

rocket.birthRate        = 10;//每秒产生120个粒子
rocket.emissionRange    = 0.25 * M_PI;  // //随机方向 -pi/4 --- pi/4
rocket.velocity            = 380;  //初始速度
rocket.velocityRange    = 100;    //随机速度 -200+380 --- 200+380
rocket.yAcceleration    = 75;     //给Y方向一个加速度
rocket.lifetime            = 1.02;   // 存活1.02秒

rocket.contents            = (id) [[UIImage imageNamed:@&quot;DazRing&quot;] CGImage];
rocket.scale            = 0.2;
rocket.color            = [[UIColor redColor] CGColor];
rocket.greenRange        = 1.0;
rocket.redRange            = 1.0;       //三个随机颜色
rocket.blueRange        = 1.0;
rocket.spinRange        = M_PI;        // slow spin



// the burst object cannot be seen, but will spawn the sparks
// we change the color here, since the sparks inherit its value
CAEmitterCell *burst = [CAEmitterCell emitterCell];

burst.birthRate            = 1.0;        // at the end of travel
burst.velocity            = 0;           //初始速度
burst.scale                = 2.5;        //
burst.redSpeed            =-1.5;        // 颜色变化效果
burst.blueSpeed            =+1.5;        // 颜色变化效果
burst.greenSpeed        =+1.0;        // 颜色变化效果
burst.lifetime            = 0.35;      //存活0.35秒


// and finally, the sparks
CAEmitterCell* spark = [CAEmitterCell emitterCell];

spark.birthRate            = 400;          //每秒产生400个粒子
spark.velocity            = 125;        //初始速度
spark.emissionRange        = 2* M_PI;   //随机方向  360 度
spark.yAcceleration        = 75;        // gravity
spark.lifetime            = 3;          //存活3秒

spark.contents            = (id) [[UIImage imageNamed:@&quot;snow&quot;] CGImage];
spark.scaleSpeed        =-0.2;    //逐渐变小

spark.greenSpeed        =-0.1;
spark.redSpeed            = 0.4;   //三种随机色
spark.blueSpeed            =-0.1;

spark.alphaSpeed        =-0.25;     //逐渐消失
spark.alphaRange           = 0.75;  //随机透明度
spark.spin                = 2* M_PI;
spark.spinRange            = 2* M_PI;

// 全部加起来
fireworksEmitter.emitterCells    = [NSArray arrayWithObject:rocket];
rocket.emitterCells                = [NSArray arrayWithObject:burst];
burst.emitterCells                = [NSArray arrayWithObject:spark];
[self.view.layer addSublayer:fireworksEmitter];
</code></pre><p>}</p>
<p>图就不贴了，主要是要知道属性的意思。</p>
<h2 id="基础动画CABasicAnimation"><a href="#基础动画CABasicAnimation" class="headerlink" title="基础动画CABasicAnimation:"></a>基础动画CABasicAnimation:</h2><p>继承于CAPropertyAnimation,一下介绍几个常见的熟悉<br>keyPath 动画方式，fromValue 从 toValue 到   repeatCount执行动画的次数，duration持续时间 ,autoreverses是否自动发转</p>
<p>//先初始化一个imageView<br>    self.heart = [[UIImageView alloc] initWithFrame:CGRectMake(50, 50, 200, 200)];<br>    self.heart.image = [UIImage imageNamed:@”4458.jpg”];<br>    [self.view addSubview:self.heart];</p>
<p>//实例化动画<br>   CABasicAnimation * animation = [CABasicAnimation animation];</p>
<pre><code>//缩放动画
//设置缩放属性
animation.keyPath = @&quot;transform.scale&quot;;
animation.toValue = @0.1;//缩到0.1
animation.fromValue = @0.5;//从0.5开始缩

//设置动画的其他属性
//设置动画的执行次数 MAXFLOAT 无线循环
animation.repeatCount = MAXFLOAT;
//设置动画自动发转，怎么去，怎么回
animation.autoreverses = YES;
//设置动画的执行时长
animation.duration = 0.25;
//添加动画到层上
[self.heart.layer addAnimation:animation forKey:nil];


    //旋转动画
//设置缩放属性
animation.keyPath = @&quot;transform.rotation&quot;;
animation.toValue = @(M_PI * 2);
//设置动画重复次数
animation.repeatCount = MAXFLOAT;
//设置动画执行时间
animation.duration = 1;
//添加动画到layer
  //添加动画到层上
[self.heart.layer addAnimation:animation forKey:nil];

//平移动画
 //keyPath可设置为x，y，z在对应方向平移或者直接写成transform.translation，在x和y方向同时平移
 animation.keyPath = @&quot;transform.translation.x&quot;;
animation.fromValue = @(-CGRectGetWidth(self.heart.bounds));
animation.toValue =  @(CGRectGetWidth(self.heart.bounds));
//设置动画重复次数
animation.repeatCount = MAXFLOAT;
//设置动画执行时间
animation.duration = 1;
//添加动画到layer
[self.heart.layer addAnimation:animation forKey:nil];
</code></pre><h2 id="关键帧动画CAKeyframeAnimation"><a href="#关键帧动画CAKeyframeAnimation" class="headerlink" title="关键帧动画CAKeyframeAnimation:"></a>关键帧动画CAKeyframeAnimation:</h2><p>是CApropertyAnimation的子类，跟CABasicAnimation的区别是：CABasicAnimation只能从一个数值(fromValue)变到另一个数值(toValue)，而CAKeyframeAnimation会使用一个NSArray保存这些数值</p>
<ul>
<li><p>属性解析：</p>
</li>
<li><p>values：就是上述的NSArray对象。里面的元素称为”关键帧”(keyframe)。动画对象会在指定的时间(duration)内，依次显示values数组中的每一个关键帧</p>
</li>
<li><p>path：可以设置一个CGPathRef\CGMutablePathRef,让层跟着路径移动。path只对CALayer的anchorPoint和position起作用。如果你设置了path，那么values将被忽略</p>
</li>
<li><p>keyTimes：可以为对应的关键帧指定对应的时间点,其取值范围为0到1.0,keyTimes中的每一个时间值都对应values中的每一帧.当keyTimes没有设置的时候,各个关键帧的时间是平分的</p>
</li>
<li><p>说明：CABasicAnimation可看做是最多只有2个关键帧的CAKeyframeAnimation</p>
<p>//先初始化一个imageView</p>
<pre><code>self.iv = [[UIImageView alloc] initWithFrame:CGRectMake(50, 100, 200, 200)];
</code></pre><p>  [self.view addSubview:self.iv];<br>  self.iv.image = [UIImage imageNamed:@”4458.jpg”];<br>  CAKeyframeAnimation *anim = [CAKeyframeAnimation animation];</p>
<p>   // 1. 抖动幅度</p>
<pre><code>//anim.values = @[@(angle2Rad(-3)),@(angle2Rad(3)),@(angle2Rad(-3))];
</code></pre><p>  // 2. 抖动幅度还可以使用path<br>  anim.path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, 5, 5)].CGPath;<br>  anim.duration = 2;//抖动时间<br>  //把抖动效果的原点由图片的中心点改成 左上角<br>  self.iv.layer.anchorPoint = CGPointZero;<br>  anim.keyPath = @”transform.rotation”;//旋转                anim.repeatCount = MAXFLOAT;<br>  [self.iv.layer addAnimation:anim forKey:nil];</p>
<p>还可以根据手势移动：</p>
<ul>
<li><p>(void)touchesBegan:(NSSet<uitouch *=""> <em>)touches withEvent:(UIEvent </em>)event<br>{<br>UITouch <em>touch = [touches anyObject];<br>// 获取手指的触摸点<br>CGPoint curP = [touch locationInView:self.iv];<br>// 创建路径<br>UIBezierPath </em>path = [UIBezierPath bezierPath];<br>_path = path;<br>//设置起点<br>[path moveToPoint:curP];</uitouch></p>
<p>}</p>
<ul>
<li>(void)touchesMoved:(NSSet<uitouch *=""> <em>)touches withEvent:(UIEvent </em>)event<br>{<br>UITouch *touch = [touches anyObject];</uitouch></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>//获取手指的触摸点
CGPoint curP = [touch locationInView:self.iv];

[_path addLineToPoint:curP];

[self.view setNeedsDisplay];
}

- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event
{
//给imageView 添加核心动画
CAKeyframeAnimation *anim = [CAKeyframeAnimation animation];
anim.keyPath = @&quot;position&quot;;

anim.path = _path.CGPath;

anim.duration = 2;

anim.repeatCount = MAXFLOAT;

[self.iv.layer addAnimation:anim forKey:nil];
}

- (void)drawRect:(CGRect)rect
{   //划线
[_path stroke];
}  ` 
</code></pre><p>对了，这是宏定义合申明</p>
<pre><code>#define angle2Rad(angle) ((angle) / 180.0 * M_PI)
@property (nonatomic,strong) UIBezierPath   *path;
@property (nonatomic,strong)UIImageView *iv;
@property (nonatomic,strong)UIImageView *heart;
</code></pre><h2 id="形变-CATransform3D"><a href="#形变-CATransform3D" class="headerlink" title="形变 CATransform3D:"></a>形变 CATransform3D:</h2><p>CATransform3D是一个用于处理3D形变的类,其可以改变控件的平移、缩放、旋转、斜交等,其坐标系统采用的是三维坐标系,即向右为x轴正方向,向下为y轴正方向,垂直屏幕向外为z轴正方向。在CALayer中有一个transform属性便是专门用来控制3D形变的，</p>
<p> CATransform3D MakeTranslation (CGFloat tx, CGFloat ty, CGFloat tz);<br>    //CATransform3DMakeTranslation实现以初始位置为基准,在x轴方向上平移x单位,在y轴方向上平移y单位,在z轴方向上平移z单位</p>
<p>####平移动画####<br>        [UIView animateWithDuration:0.6 animations:^{<br>            iv.layer.transform = CATransform3DMakeTranslation(100, 100, 0);<br>        }];</p>
<p>####缩放####<br>        CATransform3D MakeScale (CGFloat sx, CGFloat sy, CGFloat sz);<br>    //CATransform3DMakeScale实现以初始位置为基准,在x轴方向上缩放x倍,在y轴方向上缩放y倍,在z轴方向上缩放z倍<br>        [UIView animateWithDuration:0.6 animations:^{<br>        iv.layer.transform = CATransform3DMakeScale(2, 0.5, 1);<br>    }];</p>
<p>####旋转####<br>        CATransform3D MakeRotation (CGFloat angle, CGFloat x, CGFloat y, CGFloat z);<br>    // CATransform3DMakeRotation实现以初始位置为基准,在x轴,y轴,z轴方向上逆时针旋转angle弧度(弧度=π/180×角度,M_PI弧度代表180角度),x,y,z三个参数只分是否为0<br>            [UIView animateWithDuration:0.6 animations:^{<br>        iv.layer.transform = CATransform3DMakeRotation(M_PI*0.25, 0, 0, 1);<br>    }];</p>
<p>####恢复####<br> transform属性默认值为CATransform3DIdentity,可以在形变之后设置该值以还原到最初状态</p>
<pre><code>iv.layer.transform = CATransform3DIdentity;
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">


      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/child/2016/10/31/description/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="hapii">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://tva1.sinaimg.cn/crop.0.14.750.750.180/005PluWajw8fahgdnankoj30ku0lnjsd.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="不要急，不要怕">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="不要急，不要怕" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/31/description/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-10-31T12:40:41+08:00">
                2016-10-31
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/10/31/description/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/10/31/description/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/10/31/description/" class="leancloud_visitors" data-flag-title="">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>title: <object returned="" empty="" description=""><br>date: 2015-10-31 12:40:41<br>categories: [日常Bug]<br>tags: [nil]</object></p>
<p>前几天在开发中要根据id来请求一个网址，所以就加了一个判断</p>
<pre><code>     if (!video.url) {
    video.url = [self getUrlFormId:video.id];
} 
</code></pre><p> 但是居然不走里边的方法，po结果一看原来是<br>    <object returned="" empty="" description=""><br>之后改成</object></p>
<pre><code>    if ([video.url isEqualToString:@&quot;&quot;]) {
    video.url = [self getUrlFormId:video.id];
} 
</code></pre><p>就好了，应该是字典模型转化的时候为了安全自动赋值了吧。</p>
<h2 id="几种空的区别"><a href="#几种空的区别" class="headerlink" title="几种空的区别:"></a>几种空的区别:</h2><p>这里就要必要说一下iOS 中几种空的区别了，做学问要认真嘛</p>
<p>nil：指向oc中对象的空指针<br>Nil：指向oc中类的空指针<br>NULL：指向其他类型的空指针，如一个c类型的内存指针<br>NSNull：在集合对象中，表示空值的对象</p>
<p>nil和NULL从字面意思来理解比较简单，nil是一个对象，而NULL是一个值，我的理解为nil是将对象设置为空，而NULL是将基本类型设置为空的。而且我们对于nil调用方法，不会产生crash或者抛出异常。<br>看一下用法</p>
<pre><code>NSURL *url = nil；
Class class = Nil；
int *pointerInt = NULL；
nil是一个对象指针为空，Nil是一个类指针为空，NULL是基本数据类型为空。
</code></pre><p>这五个概念很容易混淆，在一些场合下他们具有同样的用法。首先解释一下“空指针”意思，空指针是指该指针未指向一块有意义的内存区。如int <em>p; int </em>p = NULL;</p>
<pre><code>NSObject *obj1 = [[NSObject alloc] init];
NSObject *obj2 = [NSNull null];    
NSObject *obj3 = [NSObject new];
NSObject *obj4;
NSArray *arr1 = [NSArray arrayWithObjects:obj1, obj2, obj3, obj4, nil];
NSLog(@&quot;arr1 count: %ld&quot;, [arr1 count]); //count: 3 因为obj=nil，在加入obj4时就结束添加对象
NSObject *obj1;
NSObject *obj2 = [[NSObject alloc] init];
NSObject *obj3 = [NSNull null];
NSObject *obj4 = [NSObject new];
NSArray *arr2 = [NSArray arrayWithObjects:obj1, obj2, obj3, obj4, nil];
NSLog(@&quot;arr2 count: %ld&quot;, [arr2 count]); //count: 0，因为obj1=nil，所以后面的对象没有添加进去

[NSNull null]通常作为占位符作用，如下：
NSObject *obj1 = [NSNull null];
NSArray *arr1 = [NSArray arrayWithObjects:@&quot;One&quot;, @&quot;TWO&quot;, obj1,@&quot;three&quot;,nil];
for (NSString *str in arr1) {
NSLog(@&quot;array object: %@&quot;, str);
} //result：One、Two、、three


NSObject *obj1 = [NSNull null]; 
NSArray *arr1 = [NSArray arrayWithObjects:@&quot;One&quot;, @&quot;TWO&quot;, obj1,@&quot;three&quot;,nil];
for (NSString *str in arr1) {
if (str != [NSNull null]){
NSLog(@&quot;array object: %@&quot;, str);
} 
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">


      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/child/2016/10/27/FMDB存取字典/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="hapii">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://tva1.sinaimg.cn/crop.0.14.750.750.180/005PluWajw8fahgdnankoj30ku0lnjsd.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="不要急，不要怕">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="不要急，不要怕" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/27/FMDB存取字典/" itemprop="url">
                  FMDB存取字典
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-10-27T13:24:58+08:00">
                2016-10-27
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/10/27/FMDB存取字典/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/10/27/FMDB存取字典/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/10/27/FMDB存取字典/" class="leancloud_visitors" data-flag-title="FMDB存取字典">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面:"></a>写在前面:</h2><p>ios 中常用的有以下几种方式<br>1、XML属性列表（plist）归档<br>2、Preference(偏好设置)NSuserDefault<br>3、NSKeyedArchiver归档(NSCoding)<br>4、SQLite3<br>5、Core Data<br>  我在开发中最常用的就是2，4了，2可以存储一些字符串什么的，而4可以存一些稍大的数据。虽然苹果官方推荐CoreData,并且好多人都说他好用,但是研究了一下感觉又不方便有重，（可能没用习惯吧）数据如果不是太多的话没有必要用，再说coreData也是基于sqlit3。<br>    第三方框架FMDB，它是对libsqlite3框架的封装，用起来的步骤与SQLite使用类似，并且它对于多线程的并发操作进行了处理，使用简单安全.</p>
<h2 id="存储字典"><a href="#存储字典" class="headerlink" title="存储字典:"></a>存储字典:</h2><ul>
<li>(BOOL)executeUpdate:(NSString*)sql, …可以看到这个方法存储的是字符串，但是在开发中如果我们需要存储字典和字符串怎么办？<br>两种方法：<ul>
<li>(BOOL)executeUpdate:(NSString<em>)sql withParameterDictionary:(NSDictionary </em>)arguments,有一个这个函数，但是抱歉整了两个小时没整出来，丢人…有时间再说，，待续<br>另一种就比较简单了（一开始看不上这个方法，但最后还是用的它）<br>在存储时讲字典转化为Json字符串：<br>NSDictionary  <em>dic = vc.jumpBaseInfo;<br>NSError </em>parseError = nil;<br>NSData *jsonData = [NSJSONSerialization dataWithJSONObject:dic options:NSJSONWritingPrettyPrinted error:&amp;parseError];<br>vc.collectionStr =  [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];</li>
</ul>
</li>
</ul>
<p>然后存进数据库：<br>[_lock lock];<br>NSString *sql = @”insert into QXNNews (loadUrl,detailID,collectionStr) values (?,?,?)”;</p>
<p>BOOL isSuccess = [_fmdb executeUpdate:sql,vc.loadUrl,vc.detailID,vc.collectionStr];</p>
<p>[_lock unlock];</p>
<p>在读取时：<br>//再将json字符串转化为字典：<br>NSData *jsonData = [vc.collectionStr dataUsingEncoding:NSUTF8StringEncoding];</p>
<p>NSError *err;<br>//得到字典<br>vc.jumpBaseInfo = [NSJSONSerialization JSONObjectWithData:jsonData</p>
<p>options:NSJSONReadingMutableContainers</p>
<p>error:&amp;err];</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>数据库博大精深，FMDB就是好用。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">


      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://tva1.sinaimg.cn/crop.0.14.750.750.180/005PluWajw8fahgdnankoj30ku0lnjsd.jpg"
               alt="hapii" />
          <p class="site-author-name" itemprop="name">hapii</p>
          <p class="site-description motion-element" itemprop="description">Stay Hungry. Stay Foolish.</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">39</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/hapiii" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/5339381110/profile?topnav=1&wvr=6&is_all=1" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/users/d746cffd2a58/timeline" target="_blank" title="简书">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  简书
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/oncezhu/activities" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hapii</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"hapii"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  








  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("zc81aNb6TWWwuKFCHYYHVEwj-gzGzoHsz", "fzUiJKfzp0BdJLPgoyW4Tf5w");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  


</body>
</html>
